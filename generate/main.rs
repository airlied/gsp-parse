use std::env;
use std::fs::File;
use std::collections::BTreeMap;
use std::io::{BufReader, BufRead, Write};
use serde::{Deserialize, Serialize};

const SPECIAL_TYPES:  [&str;8] = ["NvU32", "NvU64", "NvU16", "NvU8", "NvBool", "char", "NvHandle", "int"];

#[derive(Serialize, Deserialize, Clone)]
enum FieldType {
    Member,
    UnionStart,
    UnionEnd,
    StructStart,
    StructEnd,
}

#[derive(Serialize, Deserialize, Clone)]
struct CStructField {
    fldtype: FieldType,
    ftype: String,
    name: String,
    is_array: bool,
    size: u32,
    is_aligned: bool,
    alignment: u32,
}

#[derive(Serialize, Deserialize, Default, Clone)]
enum CType {
    #[default]
    Unknown,
    Value,
    Struct,
    Typedef,
}

#[derive(Serialize, Deserialize, Default, Clone)]
struct CTypes {
    ctype: CType,
    vals: Vec<String>,
    is_anon_struct: bool,
    // for structs
    fields: Vec<CStructField>,
}

#[derive(Serialize, Deserialize, Default)]
struct CJson {
    version: String,
    types: BTreeMap<String, CTypes>,
}

#[derive(Serialize, Deserialize, Default)]
struct WantedJson {
    structs: Vec<String>,
    cmds: BTreeMap<String, Vec<String>>,
    defines: Vec<String>,
}

fn generate_define(out_writer: &mut File, verstr: &str, defname: &String, define: &CTypes) -> std::io::Result<()> {
    if define.vals.len() == 2 {
	writeln!(out_writer, "#define {} {}:{}", defname, define.vals[0], define.vals[1])?;
    } else {
	writeln!(out_writer, "#define {} {}", defname, define.vals[0])?;
    }
    Ok(())
}

fn generate_struct(out_writer: &mut File, verstr: &str, strname: &String, cstruct: &CTypes) -> std::io::Result<()> {
    if cstruct.fields.len() > 0 {
	writeln!(out_writer, "typedef struct {} {{", strname)?;
    }
    let mut cur_level = 1;
    for field in &cstruct.fields {
	let mut indent: String = "".to_string();
	for _ in 0..cur_level {
	    indent += "    ";
	}
	match field.fldtype {
	    FieldType::Member => {
		let mut alignedstr = "".to_string();
		if field.is_aligned {
		    alignedstr = format!(" __attribute__ ((__aligned__({})))", field.alignment);
		}
		if field.is_array {
		    let fname = &field.ftype;
		    let mut fld_size_str = "".to_string();
		    if field.size > 0 {
			fld_size_str = format!("{}", field.size);
		    }
		    writeln!(out_writer, "{}{} {}[{}]{};", indent, fname, field.name, fld_size_str, alignedstr)?;
		} else {
		    writeln!(out_writer, "{}{} {}{};", indent, field.ftype, field.name, alignedstr)?;
		}
		
	    }
	    FieldType::UnionStart => {
		writeln!(out_writer, "{}union {{", indent);
		cur_level += 1;
	    }
	    FieldType::StructStart => {
		writeln!(out_writer, "{}struct {{", indent);
		cur_level += 1;
	    }
	    FieldType::UnionEnd => {
		cur_level -= 1;
		let mut indent: String = "".to_string();
		for _ in 0..cur_level {
		    indent += "    ";
		}
		let arrstr = match field.is_array {
		    true => { "[]" },
		    false => { "" },
		};
		let mut extraspace = "";
		if field.name != "" {
		    extraspace = " ";
		}
		    
		writeln!(out_writer, "{}}}{}{}{};", indent, extraspace, field.name, arrstr);	
	    }
	    FieldType::StructEnd => {
		cur_level -= 1;
		let mut indent: String = "".to_string();
		for _ in 0..cur_level {
		    indent += "    ";
		}
		let mut extraspace = "";
		if field.name != "" {
		    extraspace = " ";
		}		
		let arrstr = match field.is_array {
		    true => { match field.size {
			0xffffffff => { "[]" },
			x => { &format!("[{}]", field.size) },
		    }},
		    false => { "" },
		};
		writeln!(out_writer, "{}}}{}{}{};", indent, extraspace, field.name, arrstr);
	    }
	}
    }
    if cstruct.fields.len() > 0 {
	writeln!(out_writer, "}} {};", strname)?;
	writeln!(out_writer, "");
    }
    Ok(())
}

fn generate_typedef(out_writer: &mut File, verstr: &str, tdname: &String, ctypedef: &CTypes) -> std::io::Result<()> {
    writeln!(out_writer, "typedef struct {}_{} {}", tdname, verstr, ctypedef.vals[0])?;
    Ok(())
}

fn main() -> std::io::Result<()> {
    let args: Vec<String> = env::args().collect();
    let file = File::open(args[1].clone())?;
    let reader = BufReader::new(file);
    let json_input: CJson = serde_json::from_reader(reader)?;

    let sym_list = File::open(args[2].clone())?;
    let sym_reader = BufReader::new(sym_list);
    let sym_json: WantedJson = serde_json::from_reader(sym_reader)?;    

    let mut out_file = File::create(args[3].clone())?;

    let ver_str = json_input.version.replace('.', "_");
    let def_ver_str = "__NV_HEADER_".to_owned() + ver_str.as_str() + "__";
    writeln!(out_file, "/*")?;
    writeln!(out_file, " * SPDX-FileCopyrightText: Copyright (c) 2022 NVIDIA CORPORATION & AFFILIATES. All rights reserved")?;
    writeln!(out_file, " * SPDX-License-Identifier: MIT")?;
    writeln!(out_file, " * This file is autogenerated from NVIDIA headers")?;
    writeln!(out_file, " * in https://github.com/NVIDIA/open-gpu-kernel-module")?;
    writeln!(out_file, " * on the {} branch", json_input.version);
    writeln!(out_file, " */")?;
    writeln!(out_file, "#ifndef {}", def_ver_str)?;
    writeln!(out_file, "#define {} 1", def_ver_str)?;
    writeln!(out_file, "#define __NV_VERSION__ {}", json_input.version)?;
    writeln!(out_file)?;

    writeln!(out_file)?;

    for sym_define in sym_json.defines {
	for (defname, define) in &json_input.types {
	    if sym_define.chars().last().unwrap() == '*' {
		if defname.starts_with(&sym_define.strip_suffix("*").unwrap()) {
		    generate_define(&mut out_file, &ver_str.as_str(), &defname, &define);
		}
	    } else if *defname == sym_define {
		generate_define(&mut out_file, &ver_str.as_str(), &defname, &define);
	    }
	}
    }

    writeln!(out_file)?;
    for sym_struct in sym_json.structs {
	for (name, ctype) in &json_input.types {
	    if *name == sym_struct {
		generate_struct(&mut out_file,
				&ver_str.as_str(),
				&name,
				&ctype)?;
	    }
	}
    }

    writeln!(out_file)?;
    for cmdgroup in sym_json.cmds {
	let basename : String = "NV".to_owned() + &cmdgroup.0;
	for cmd in cmdgroup.1 {
	    let cmdname = basename.clone() + "_CTRL_CMD_" + &cmd;
	    let ctrlname = basename.clone() + "_CTRL_" + &cmd;

	    for (defname, define) in &json_input.types {
		if defname.starts_with(&cmdname) || defname.starts_with(&ctrlname) {
		    match define.ctype {
			CType::Value => { generate_define(&mut out_file,
							  &ver_str.as_str(),
							  &defname,
							  &define)?;
			}
			_ => {}
		    }
		}
	    }
	    let stname = ctrlname.clone() + "_PARAMS";
	    for (name, ctype) in &json_input.types {
		if name == &stname {
		    writeln!(out_file)?;
		    generate_struct(&mut out_file,
				    &ver_str.as_str(),
				    &name,
				    &ctype);

		}
	    }
	    let stname = cmdname.clone() + "_PARAMS";
	    for (name, ctype) in &json_input.types {
		if name == &stname {
		    writeln!(out_file)?;
		    generate_struct(&mut out_file,
				    &ver_str.as_str(),
				    &name,
				    &ctype);

		}
	    }	    
	}
    }

    

    writeln!(out_file, "#endif")?;
    Ok(())
}
